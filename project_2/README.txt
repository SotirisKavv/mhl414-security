GCC Version

gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


App Logic

Η λογική της εφαρμογής για κάθε επιλογή ακολουθούσε τη δομή ως εξής:
1. Αρχικά ανοίγει το input file, ώστε να διαβάσουμε bytes απ' αυτό.
2. Στη συνέχεια, δημιουργείται το κλειδί, με βάση τις παραμέτρους που
επιλέξαμε, έχοντας δεσμέυσει την κατάλληλη μνήμη.
3. Ύστερα, εκτελείται ο κώδικας που αντιστοιχεί στην κάθε λειτουργία.
4. Τέλος, αν όλα έχουν πάει καλά στην προηγούμενη διαδικασία, δημιουργείται
ένα αρχείο εξόδου, στο οποίο γράφουμε σε μορφή bytes το κρυπτογραφημένο ή
αποκρυπτογραφημένο μήνυμα που δημιουργήθηκε από την αντίστοιχη λειτουργία.

Αναλυτικά:

KDF (TASK A):
Αρχικά, ανάλογα με το bit_mode που έχουμε δώσει ως όρισμα, επιλέγεται το 
κατάλληλο cipher, μέσω της συνάρτησης EVP_get_cipherbyname, και όρισμα της
"aes-256-ecb" ή "aes-128-ecb". Στη συνέχεια μέσω της EVP_get_digestbyname("sha1")
επιλέγεται η συνάρτηση κατακερματισμού κρυπτογράφησης SHA1. Τέλος, μέσω της
EVP_BytesToKey και των κατάλληλων ορισμάτων, δημιουργείται το κλειδί 
κρυπτογράφησης και αποθηκεύεται στη μεταβλητή/πίνακα key, που χρησιμοποιήθηκε
ως όρισμα στην συνάρτηση εξ αρχής. Σε περίπτωση λάθους, η εφαρμογή τερματίζει.

Data Encryption (TASK B):
Η κρυπτογράφηση λειτουργεί ως εξής:
Πρώτα επιλέγεται το κατάλληλο cipher με βάση το bit_mode, όπως και στην παραπάνω
συνάρτηση (keygen). Ύστερα χρησιμοποιείται το API του EVP για την κρυπτογράφηση
του plaintext που δώθηκε ως argument. Αυτή η διαδικασία γίνεται με τις συναρτήσεις
EVP_EncryptInit_ex, EVP_EncryptUpdate και EVP_EncryptFinal_ex. Τέλος επιστρέφεται
το μήκος του ciphertext σε bytes. Έξω από την encrypt, ανοίγει το αρχείο εξόδου 
σε mode "wb" (write bytes), και με την fwrite γράφεται το ciphertext στο output
file.

Data Decryption (TASK C):
Η αποκρυπτογράφηση ακολουθεί παρόμοια διαδικασία με την κρυπτογράφηση, με τη διαφορετικά
ότι οι συναρτήσεις του EVP API που χρησιμοποιούνται είναι οι EVP_DecryptInit_ex, 
EVP_DecryptUpdate και EVP_DecryptFinal_ex.

Data Signing (TASK D):
Εδώ αρχικά γίνεται η κρυπτογράφηση του plaintext με τη χρήση της συνάρτησης encrypt
που δημιουργήθηκε για το TASK A. Στη συνέχεια, καλείται η συνάρτηση gen_cmac, η οποία
χρησιμοποιώντας το CMAC API και τα ορίσματα plaintext, key και bit_mode, παράγει το 
CMAC. Έπειτα, χρησιμοποιώντας τη συνάρτηση uconcat, γίνεται η συνένωση του ciphertext
με το cmac, καθώς και τα δύο είναι unsigned char arrays, δηλαδή bytestreams, και άρα η 
strcat δεν μπορεί να χρησιμοποιηθεί. Έπειτα, ακολουθείται η διαδικασία εγγραφής
σε αρχείο εξόδου.

Data verification (TASK E):
Έχοντας ήδη διαβάσει το περιεχόμενο του input file, αντιγράφουμε την τιμή των τελευταίων 
16 bytes με τη memcpy, καθώς εκεί βρίσκεται το cmac που χρησιμοποιήθηκε για το signing.
Έπειτα, γίνεται η αποκρυπτογράφηση του ciphertext, χωρίς τα τελευταία 16 bytes, για τους 
λόγους που αναφέρθηκαν παραπάνω. Δημιουργείται εκ νέου ένα cmac από το αποκρυπτογραφημένο
ciphertext. Στη συνέχεια συγκρίνονται byte προς byte το cmac που αντιγράφθηκε στην αρχή 
και το cmac που δημιουργήθηκε από την αποκρυπτογράφηση. Στην περίπτωση που κάποιο byte
δεν αντιστοιχιστεί, τότε το αρχείο δε θεωρείται verified, και δε γίνεται η δημιουργία του 
output file ωστε να εγγραφθεί το plaintext/deciphered text. Διαφορετικά, προχωράει η 
διαδικασία κανονικά.

TASK F:
Τα αποτελέσματα ήταν τα εξής:
1. Το αρχείο decryptme_256.txt δημιουργείται κανονικά, και χρησιμοποιώντας το -d και τον 
ίδιο κωδικό και bit_mode, αποκρυπτογραφείται ορθά.
2. Το αρχείο hpy414_encryptme_128.txt αποκρυπτογραφείται κανονικά και το μήνυμα είναι το
εξής: 
"Hello HPY414

This file was encrypted with a 128-bit key

BB!"
3. Το αρχείο signme_128.txt έγινε κανονικά signed, και επιβεβαιώθηκε χρησιμοποιώντας τη
λειτουργία verification.
4. Κανένα από τα δύο αρχεία δε γίνεται verified.