gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0

FILE LOGGING

Η διαδικασια της καταγραφής του ελέγχου πρόσβασης λειτουργεί δρώντας πάνω στη λειτουργία 
των κλασικών συναρτήσεων της C, fopen και fwrite. Κάθε καταγραφή περιέχει στοιχεία σχετικά
με το τι έκανε ο χρήστης που κάλεσε τις συναρτήσεις. Αυτά είναι τα εξής:

    1. UID: Το μοναδικό ID του χρήστη που κάλεσε τη συνάρτηση. Το λαμβάνουμε με τη
    συνάρτηση getuid() από τη βιβλιοθήκη unistd.h

    2. FILE: Στην fopen(), το λαμβάνουμε από το αντίστοιχο όρισμα από την κλήση της 
    συνάρτησης. Στην fwrite(), το λαμβάνουμε από το File Descriptor που αντιστοιχεί 
    στο file pointer/όρισμα της συνάρτησης. Το δεύτερο γίνεται με τη χρήση των 
    συναρτήσεων fileno(stream) και readlink("/proc/self/fd/(file_desc)", ...).

    3. DATE & 4. TIME: Χρησιμοποιούμε τις συναρτήσεις time() και localtime() της 
    time.h για να λάβουμε τα αντίστοιχα πεδία.

    5. ACCESS TYPE: Στην fopen(), χρησιμοποιούμε τη συνάρτηση access() με όρισμα το 
    filename και το mode F_OK. Έτσι αν το αρχείο υπάρχει ήδη (η access() γυρνάει 0),
    τότε το ACCESS_TYPE είναι 1. Αλλιώς, το αρχείο δεν υπάρχει, άρα η fopen() θα 
    δημιουργήσει το επιθυμητό αρχείο και το ACCESS_TYPE είναι 0. Στην fwrite(), το 
    ACCESS_TYPE είναι πάντα 2, καθώς κάθε κλήση της, αλλάζει το περιεχόμενο του αρχείου.

    6. ACTION DENIED FLAG: Στην fopen(), χρησιμοποιούμε τη συνάρτηση access('filename', 
    R_OK | W_OK), ελέγχοντας αν ο χρήστης που τις κάλεσε έχει δικαίωμα ανάγνωσης ή 
    εγγραφής, καθώς αυτές τις δύο δυνατότητες έχει ο χρήστης με την fopen(). Στην 
    fwrite(), χρησιμοποιούμε την access('filename', W_OK).

    7. FINGERPRINT: Αρχικά διαβάζουμε το περιεχόμενο του τελικού κειμένου του αρχείου.
    Αρχικά ελέγχουμε αν έχουμε δικαίωμα κλήσης της fopen(), μέσω της actionDenied από 
    το πεδίο 5. Αν απαγορεύεται, τότε fingerprint είναι 0. Αφού τοποθετήσουμε τον 
    δείκτη ανάγνωσης κειμένου στην αρχή (καθώς υπάρχουν περιπτώσεις που αυτός βρίσκεται
    στο τέλος - βλ. append), διαβάζουμε όλο το κείμενο, και καλώντας τη βοηθητική 
    συνάρτηση str2md5(), λαμβάνουμε το fingerprint. Η str2md5 λειτουργεί περίπου όπως
    η encrypt/decrypt του προηγούμενου assignment, χρησιμοποιώντας το MD5 API. Στο τέλος,
    τα bytes που παράγονται από το digest, μετατρέπονται σε string, αναπαριστόντας τα σε
    δεκαεξαδική μορφή.


acmonitor.c

Για τις λειτουργίες του εργαλείου μας, σε κάθε περίπτωση, αρχικά γίνεται ανάγνωση του αρχείου
file_logging.log, και γίνεται η αποθήκευση των δεδομένων του σε έναν πίνακα τύπου struct entry.
Το εργαλείο διαθέτει δύο λειτουργίες:

    1. LIST MALICIOUS USERS
    Αρχικά βρίσκουμε όλα τα Unique IDs σε όλα τα records μας, και κρατάμε τις διακριτές τιμές
    τους. Για κάθε ένα από αυτά, ελέγχουμε αν η άδεια για πρόσβαση απορρίφθηκε (actionDenied 
    = 1). Αν ναι, και αν δεν υπάρχει ήδη αυτό το αρχείο σε έναν πίνακα που διατηρούμε τα
    διακριτά ονόματα αυτών, τότε το προσθέτουμε και αυτό στον πίνακα, αυξάνοντας παράλληλα τον
    αριθμό των αρχείων που έχει επεξεργαστεί ο χρήστης. Αν αυτός ο αριθμός ξεπεράσει το 7, τότε
    εκτυπώνεται το uid του χρήστη που το έκανε.

    2. LIST FILE'S MODIFICATIONS
    Αφού βρούμε όλα τα διακριτά UIDs που βρίσκονται στον πίνακα καταγραφών, για κάθε ένα από αυτά,
    ψάχνουμε στα αρχεία/πίνακα. Ψάχνουμε για το πρώτο fingerprint που έχει καταγραφεί για το αρχείο
    που ψάχνουμε. Έπειτα, ψάχνουμε για τυχόν διαφορές στα fingerprints που έχουν κατα γραφεί για το
    αρχείο μας. Κάθε φορά που το νέο fingerprint είναι διαφορετικό από το τελευταίο, αυξάνουμε τον
    αριθμό των μετατροπών. Αν αυτός είναι τουλάχιστον 1, τότε τον εκτυπώνουμε, μαζί με το UID του 
    χρήστη που τις έκανε. 


test_aclog.c:

Για τεστάρισμα του εργαλείου μας, έχουν φτιαχτεί κάποιες συναρτήσεις/σενάρια στα οποία 
δημιουργουνται/επανεγγράφονται αρχεία, ενώ ταυτόχρονα, προσθαφαιρούνται τα δικαιώματα 
πρόσβασης του χρήστη που τα κάλεσε. Για τον έλεγχο για τους περισσότερους χρήστες,
δημιουργήθηκαν νέοι χρήστες μέσω των 'adduser' και 'su', ενώ έγινε και κλήση του προγράμματος
από τον superuser.